\section{Case Study}
\label{sec:case_study}
In this section, we present a detailed analysis of the results obtains in Setion~\ref{sec:exp}. We show examples to understand the scenarios in which the scenarios in which PatchNet would perform well or poorly in Section~\ref{sec:good_case} and~\ref{sec:fail_case}. 

\subsection{Successful Case}
\label{sec:good_case}

\begin{figure}[t!]
\begin{lstlisting}[language=diff]
commit 	82981930125abfd39d7c8378a9cfdf5e1be2002b
Author: Eric Dumazet <...>
Date:   Thu Apr 10 20:07:59 2012 +0000

    net: cleanups in sock_setsockopt()
    
    Use min_t()/max_t() macros, reformat two comments, ... 
    
    Signed-off-by: Eric Dumazet <...>
    Signed-off-by: David S. Miller <...>


diff --git a/net/core/sock.c b/net/core/sock.c
index 0431aaf7473a..10605d2ec860 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -577,23 +577,15 @@ int sock_setsockopt(...
...
-	if (val > sysctl_wmem_max)
-   		val = sysctl_wmem_max;
+	val = min_t(u32, val, sysctl_wmem_max);   
-	if ((val * 2) < SOCK_MIN_SNDBUF)
-		sk->sk_sndbuf = SOCK_MIN_SNDBUF;
-	else
-		sk->sk_sndbuf = val * 2;
+	sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
@@ -577,23 +577,15 @@ int sock_setsockopt(...
-	if (val > sysctl_rmem_max)
-		val = sysctl_rmem_max;
+	val = min_t(u32, val, sysctl_rmem_max);
@@ -629,10 +620,7 @@ set_rcvbuf:
...
\end{lstlisting}\vspace{-0.4cm}
\caption{A true positive for PatchNet that is not detected by the other
  baselines}
\label{fig:good_case}\vspace{-0.4cm}
\end{figure}
\jg{Julia: can you please take a look at this example to see whether it's a good example?}

Figure~\ref{fig:good_case} shows an example of stable patch~\footnote{https://goo.gl/Yfi4TZ} that PatchNet is able to classify as a stable patch while the other baselines classify it as a non-stable patch. We take a look at a textual commit message of this patch, we see that there are no keywords (i.e., ``bug'', `'fix'', etc.) which help to recognize whether the example is the stable and non-stable patch. 

On the other hand, the code changes may contain sufficient information that may help maintainers to label it as the stable patch. The other baselines (i.e., LPU+SVM, F-NN) mainly constructed code features based on the code changes information, i.e., number of loops in added or removed codes, number of lines in added or removed codes, etc. However, they don't capture the sequential nature of the source code inside the code changes. LS-CNN fails to understand the code changes structure, i.e., hunks, added code, and removed code. PatchNet learns the sequential nature of source code inside the code changes and takes into account the code changes structure, hence it is able to classify the example as the stable patch.  

\subsection{Unsuccessful Case}
\label{sec:fail_case}

\begin{figure}[t!]
\begin{lstlisting}[language=diff]
commit 	fad54440438a7c231a6ae347738423cbabc936d9
Author: Julian Anastasov <...>
Date:   Fri Aug 05 00:36:28 2011 +0000

    netfilter: avoid double free in nf_reinject
    NF_STOLEN means skb was already freed
    
    Signed-off-by: Julian Anastasov <...>
    Signed-off-by: David S. Miller <...>

diff --git a/net/netfilter/nf_queue.c b/net/netfilter/nf_queue.c
index 5b466cd1272f..84d0fd47636a 100644
--- a/net/netfilter/nf_queue.c
+++ b/net/netfilter/nf_queue.c
@@ -314,0 +315 @@ void nf_reinject(...)
+	break;
\end{lstlisting}\vspace{-0.4cm}
\caption{A false negative for PatchNet that is successfully detected as
  stable by F-NN}
\label{fig:bad_case}\vspace{-0.4cm}
\end{figure}

Figure~\ref{fig:bad_case} presents an example of the patch which PatchNet fails to label as a stable patch while F-NN is able to classify it as the stable patch. According to the figure, the patch does not contain much information in both commit message as well as commit code, hence PatchNet fails to classify it as the stable patch. We note that all baselines also fail to label this patch as well except F-NN. In our opinion, F-NN uses author names as features hence it may be able to correctly label this patch. 
